/*************************1.最大子序和*********************************************/
/**
 * 给定一个整数数组 nums ，找到一个具有最大和的连续子数组(子数组最少包含一个元素)，返回 
 * 其最大和。
 * 输入: [-2,1,-3,4,-1,2,1,-5,4],
 * 输出:6
 * 解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。
 * 
 * 方法一 暴力破解
 * 思路
 * 从数组最左边开始于数组右边数据依次相加，将相加之后数据进行比较，比较之后最大值为最终结果
 * 详解
 * 1. 创建临时变量 sum 和最大值 maxNumber
 * 2. 从数组子序列左端开始遍历依次取数据
 * 3. 从数组子序列右端开始遍历依次取数据和数组左边数据依次相加
 * 4. 将相加之后值与最大值 sum 进行比较，大的值赋值与 maxNumber 
 * 5. 最终获得最大值
 */
const maxSubArray = function(nums) {
    let sum = 0;
    let maxNumber = 0;
    for (let i = 0; i < nums.length; i++) {// 从数组子序列左端开始
        for (let j = i; j < nums.length; j++) { // 从数组子序列右端开始
            sum = 0;
            for (let k = i; k <= j; k++) { // 暴力计算
                sum += nums[k];
            }
            if(sum > maxNumber){
                maxNumber = sum;
            }         
        }
    }
    return maxNumber;
}
/**
 * 复杂度分析
 * 时间复杂度: O(n3) 对于每个元素，通过三次遍历数组的其余部分来寻找它所对应的目标元 素，这将耗费 O(n3) 的时间。
 * 空间复杂度: O(1)
 */
/***
 * 方法二 动态规划法
 * 思路
 * 数组从左端开始依次和右端数据相加，两数之和为最大数 sum 。下一次相加之后和最大数进行比 较，较大数赋值与 sum 由于有负数存在，如果两数相加之后为负数，则两数之和后的最大数为上 一个数。
 * 详解
 * 1. 从数组获取第一个值为最大值 sum 和中间值 n
 * 2. 遍历数组，如果中间值n大于0,则和中间值相加，相加结果和最大值比较，较大值赋值与sum 
 * 3. 如果中间值小于0，则将当前值作为中间值
 */
const maxSubArrayOther = function(nums){
    let sum = nums[0];
    let n = nums[0];
    for (let i = 1; i < nums.length; i++) {
        if(n > 0){ // 判断中间值是否大于0
            n += nums[i];
        } else {
            n = nums[i];
        }
        // 相加后的值和最大值作比较
        if(sum < n){
            sum = n;
        }
    }
    return sum;
}

// 第一次提交
// 第二次提交
// 第三次提交
// 第四次提交
/*************************2.打家劫舍!!!!!!!??????*********************************************/
/**
 * 你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约 
 * 因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统 会自动报警。
 * 给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到 的最高金额。
 
 * 示例
 * 输入: [1,2,3,1]
 * 输出:4
 * 解释:偷窃1号房屋(金额=1)，然后偷窃3号房屋(金额=3)。
  偷窃到的最高金额 =1+3=4 。

 * 输入: [2,7,9,3,1]
 * 输出:12
 * 解释:偷窃1号房屋(金额=2),偷窃3号房屋(金额=9)，接着偷窃5号房屋(金额=1)。
 偷窃到的最高金额 =2+9+1=12 。

 *  方法二
 *  思路
 * 由于不可以在相邻的房屋闯入，所以在当前位置 n 房屋可盗窃的最大值，要么就是 n-1 房屋可盗窃 
 * 的最大值，要么就是 n-2 房屋可盗窃的最大值加上当前房屋的值，二者之间取最大值 动态规划方 程:dp[n] = MAX( dp[n-1], dp[n-2] + num ) 总体的思路是一样的，方法一中，数组长度为 0，1，2 中单独处理，切换设计的求和变量过多，6 个可以利用数组变量优化。
 * 详解
 * 1. 获取房间的个数，如果为 0，就直接返回
 * 2. 设置一个 len+1 的数组变量，初始化数组中的第一个和第二个对象，这边就可以不用单独处理
       数组长度为 1 和 2 的情况
 * 3. 每次的循环求和的结果都记录在对于长度的数组对象中，不必声明多个变量暂存。
 * 4. 然后利用动态规划公式查找 n 个最大的数组和的值
 */
const rob = function(nums) {
    const len = nums.length;
    if(len === 0) return 0;
    const dp = new Array(len + 1);
    dp[0] = 0;
    dp[1] = nums[0];
    for (let index = 2; index < len; index++) {
        dp[index] = Math.max(dp[index-1],dp[index-2] + nums[index - 1]);
    }
    return dp[len];
}
